#include "GimbalControl.hpp"
#include "util.cpp"

GimbalControl::GimbalControl()
{
    car_odom_sub = nh.subscribe<nav_msgs::Odometry>
            ("/prius/pose_ground_truth", 10, &GimbalControl::getAgentOdom, this);
    fw_odom_sub = nh.subscribe<nav_msgs::Odometry>
            ("mavros/odometry/in", 10, &GimbalControl::getFwOdom, this);
    //fw_imu_sub = nh.subscribe<sensor_msgs::Imu>
    //        ("/mavros/imu/data", 10, &GimbalControl::getFwImu, this);
    fw_pose_sub = nh.subscribe<nav_msgs::Odometry>
            ("base_pose_ground_truth", 10, &GimbalControl::getFwPose, this);
    //fw_odom_sub = nh.subscribe<nav_msgs::Odometry>
    //        ("mavros/local_position/odom", 10, &GimbalControl::getFwGPS, this);
    img_detect_sub = nh.subscribe<darknet_ros_msgs::BoundingBoxes>
            ("/darknet_ros/bounding_boxes", 10, &GimbalControl::getDetectInfo, this);
    detect_object_sub = nh.subscribe<darknet_ros_msgs::ObjectCount>
            ("/darknet_ros/found_object", 10, &GimbalControl::checkIsDetect, this);
    gimbal_sub = nh.subscribe<sensor_msgs::JointState>
            ("gimbal/joint_states", 10, &GimbalControl::getGimbalState, this);
    cameraInfo_sub = nh.subscribe<sensor_msgs::CameraInfo>
            ("camera_ir/camera/color/camera_info", 10, &GimbalControl::getCameraInfo, this);
    angCommand_pub = nh.advertise<mavros_msgs::MountControl>
            ("mavros/mount_control/command", 10);
    pitchVelCommand_pub = nh.advertise<std_msgs::Float32>
            ("gimbal/pitch/cmd_joint_velocity", 10);
    yawVelCommand_pub = nh.advertise<std_msgs::Float32>
            ("gimbal/yaw/cmd_joint_velocity", 10);
    error_pub = nh.advertise<geometry_msgs::Point >
            ("tracking/image_error/yolo", 10);
    error_pos_pub = nh.advertise<geometry_msgs::Point >
            ("tracking/image_error/position", 10);
    gimbal_cmd_sub = nh.subscribe<mavros_msgs::MountControl>
            ("gimbal/cmd/angle", 10, &GimbalControl::cmdGimbalAng, this);
    gain_sub = nh.subscribe<std_msgs::Float32>
            ("tracking/control_gain", 10, &GimbalControl::getNewGain, this);

    estimate_dyn_pub = nh.advertise<fw_control::Dynamics>
            ("estimation/ukf/dynamics", 10);
    estimate_cam_pub = nh.advertise<fw_control::CameraFeatures>
            ("estimation/ukf/camera_features", 10);
    ukf_sub = nh.subscribe<fw_control::EstimateOutput>
            ("estimation/ukf/output_data", 10, &GimbalControl::getUKFResults, this);

    commandAng.mode = 2;
    nh.getParam("gain_lambda", lambda);
    nh.getParam("gain_nu", nu);
    nh.getParam("target", trackingTarget);
    nh.getParam("probability", legal_probability);
}

GimbalControl::~GimbalControl()
{
    
}

void GimbalControl::getUKFResults(const fw_control::EstimateOutput::ConstPtr& data)
{
    carPos_ukf.position.x = data->target_pose.x;
    carPos_ukf.position.y = data->target_pose.y;
    carPos_ukf.position.z = data->target_pose.z;
    carVel_ukf << data->target_vel.x, data->target_vel.y, data->target_vel.z;
}

void GimbalControl::getNewGain(const std_msgs::Float32::ConstPtr& gain)
{
    lambda_push = gain->data;
    gain_push = 1;
}

void GimbalControl::cmdGimbalAng(const mavros_msgs::MountControl::ConstPtr& ang)
{
    angPitch = ang->pitch;
    angYaw = ang->yaw;
}

// under inertial frame
void GimbalControl::getAgentOdom(const nav_msgs::Odometry::ConstPtr& odom)
{
    carVel << odom->twist.twist.linear.x, odom->twist.twist.linear.y, odom->twist.twist.linear.z;

    carPos.position.x = odom->pose.pose.position.x;
    carPos.position.y = odom->pose.pose.position.y;
    carPos.position.z = odom->pose.pose.position.z;
}

void GimbalControl::getFwOdom(const nav_msgs::Odometry::ConstPtr& odom)
{
    // current frame of plane (flu)
    fwAngVel << odom->twist.twist.angular.x, odom->twist.twist.angular.y, odom->twist.twist.angular.z;
    // frame: flu -> frd
    fwAngVel = Quat2RotaMatrix(baseLink_frd) * fwAngVel;
}

void GimbalControl::getFwImu(const sensor_msgs::Imu::ConstPtr& data)
{
    fwAngVel << data->angular_velocity.x, data->angular_velocity.y, data->angular_velocity.z;
    fwAngVel = Quat2RotaMatrix(baseLink_frd) * fwAngVel;
}

void GimbalControl::getFwPose(const nav_msgs::Odometry::ConstPtr& pose)
{
    fwPos.position.x = pose->pose.pose.position.x; 
    fwPos.position.y = pose->pose.pose.position.y;
    fwPos.position.z = pose->pose.pose.position.z; 

    fwVel << pose->twist.twist.linear.x, pose->twist.twist.linear.y, pose->twist.twist.linear.z;

    quat_planeEarth_flu = Eigen::Quaternionf( pose->pose.pose.orientation.w, pose->pose.pose.orientation.x, pose->pose.pose.orientation.y, pose->pose.pose.orientation.z );
    quat_planeEarth_frd =  baseLink_frd * quat_planeEarth_flu;
}

void GimbalControl::getFwGPS(const nav_msgs::Odometry::ConstPtr& msg)
{
    fwPos.position.x = msg->pose.pose.position.x; 
    fwPos.position.y = msg->pose.pose.position.y;
    fwPos.position.z = msg->pose.pose.position.z;  

    fwVel << msg->twist.twist.linear.x, msg->twist.twist.linear.y, msg->twist.twist.linear.z;

    quat_planeEarth_flu = Eigen::Quaternionf( msg->pose.pose.orientation.w, msg->pose.pose.orientation.x, msg->pose.pose.orientation.y, msg->pose.pose.orientation.z );
    quat_planeEarth_frd =  baseLink_frd * quat_planeEarth_flu;
}

void GimbalControl::getCameraInfo(const sensor_msgs::CameraInfo::ConstPtr& msg)
{
    camInfo.K = msg->K;
    
    fx = camInfo.K[0];
    fy = camInfo.K[4];
    cu = camInfo.K[2];
    cv = camInfo.K[5];
}

void GimbalControl::checkIsDetect(const darknet_ros_msgs::ObjectCount::ConstPtr& data)
{
    objFind = data->count;
    if(objFind == 0)
    {
        isDetected = false;
    }
}

void GimbalControl::getDetectInfo(const darknet_ros_msgs::BoundingBoxes::ConstPtr& info)
{
    if(objFind > 0)
    {
        int objLen =  end(info->bounding_boxes) - begin(info->bounding_boxes);

        for(int i = 0; i < objLen; i++){

            //std::cout << "item: " << i+1 << std::endl;

            if(info->bounding_boxes[i].Class == trackingTarget && info->bounding_boxes[i].probability >= legal_probability)
            {
                u = (info->bounding_boxes[0].xmax + info->bounding_boxes[0].xmin)/2;
                v = (info->bounding_boxes[0].ymax + info->bounding_boxes[0].ymin)/2;
                isDetected = true;
                detectObj = info->bounding_boxes[0].Class;
                std::cout << "The detect result is " << detectObj << std::endl;
                break;
            }
            if(info->bounding_boxes[i].Class == trackingTarget && info->bounding_boxes[i].probability < legal_probability)
            {
                u = NAN;
                v = NAN;
                isDetected = false;
            }
            if(info->bounding_boxes[i].Class != trackingTarget)
            {
                u = NAN;
                v = NAN;
                isDetected = false;
                detectObj = info->bounding_boxes[0].Class;
                std::cout << "The detect result is " << detectObj << std::endl;
            }
        }
    }
    else
    {
        u = NAN;
        v = NAN;
        isDetected = false;
        //std::cout << "No object detected." << std::endl;
    }
}

void GimbalControl::getGimbalState(const sensor_msgs::JointState::ConstPtr& state)
{
    gimbalAng[0] = state->position[0];
    gimbalAng[1] = state->position[1];
    gimbalAng[2] = state->position[2];
    gimbalAngVel[0] = state->velocity[0];
    gimbalAngVel[1] = state->velocity[1];
    gimbalAngVel[2] = state->velocity[2];
}

void GimbalControl::calCamOrientation()
{
    R_panPlane = rotationMatrix('Z', gimbalAng[2]);
    R_camPan = rotationMatrix('X', 90*M_PI/180) * rotationMatrix('Z', 90*M_PI/180) * rotationMatrix('Y', gimbalAng[1]);
}


void GimbalControl::calRelPose()
{
    //std::cout << "car position: " << carPos.position.x << ", " << carPos.position.y << ", " << carPos.position.z << std::endl;
    //std::cout << "plane position: " << fwPos.position.x << ", " << fwPos.position.y << ", " << fwPos.position.z << std::endl;
 
    Eigen::Vector3f relPos;

    // inertial frame
    relPos << (carPos.position.x - fwPos.position.x), (carPos.position.y - fwPos.position.y), (carPos.position.z - fwPos.position.z);
    // plane flu
    relPos_carPlane = Quat2RotaMatrix(quat_planeEarth_flu) * relPos;
    relPos_carCam << (relPos_carPlane[0] - relPos_camPlane(0)), (relPos_carPlane[1] - relPos_camPlane(1)), (relPos_carPlane[2] - relPos_camPlane(2));

    //std::cout << "rel pose inertial: " << relPos << std::endl;
}

void GimbalControl::Switch2CamFrame()
{
    carVel_ = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * carVel;
    fwVel_ = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * fwVel;
    fwAngVel_ =  R_camPan * R_panPlane * fwAngVel;
    relPos_camPlane_ = R_camPan * R_panPlane * Quat2RotaMatrix(baseLink_frd) * relPos_camPlane;
    relPos_carCam_ =  R_camPan * R_panPlane * Quat2RotaMatrix(baseLink_frd) * relPos_carCam;

    //std::cout << "came frame relPos_camPlane_: " << relPos_camPlane_[0] << ", " << relPos_camPlane_[1] << ", " << relPos_camPlane_[2] << std::endl;
    std::cout << "came frame relPos_carCam_: " << relPos_carCam_[0] << ", " << relPos_carCam_[1] << ", " << relPos_carCam_[2] << std::endl;
}




/*
void GimbalControl::calRelPose()
{
    //std::cout << "car position: " << carPos.position.x << ", " << carPos.position.y << ", " << carPos.position.z << std::endl;
    //std::cout << "plane position: " << fwPos.position.x << ", " << fwPos.position.y << ", " << fwPos.position.z << std::endl;
 
    Eigen::Vector3f relPos;

    // inertial frame -> car and uav
    relPos << (carPos.position.x - fwPos.position.x), (carPos.position.y - fwPos.position.y), (carPos.position.z - fwPos.position.z);
    // pan frame -> car and pan
    relPos_carPlane_pan = R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * relPos;
    // pan frame -> cam and uav
    relPos_camPlane_pan = R_panPlane * Quat2RotaMatrix(baseLink_frd) * relPos_panPlane_flu + relPos_camPan_pan;
    relPos_carCam_pan << (relPos_carPlane_pan[0] - relPos_camPlane_pan[0]), (relPos_carPlane_pan[1] - relPos_camPlane_pan[1]), (relPos_carPlane_pan[2] - relPos_camPlane_pan[2]);
    
    std::cout << "relPos_camPlane_pan: " << relPos_camPlane_pan[0] << ", " << relPos_camPlane_pan[1] << ", " << relPos_camPlane_pan[2] << std::endl;
    std::cout << "relPos_carCam_pan: " << relPos_carCam_pan[0] << ", " << relPos_carCam_pan[1] << ", " << relPos_carCam_pan[2] << std::endl;

    //relPos_carCam << (relPos_carPlane[0] - relPos_camPlane(0)), (relPos_carPlane[1] - relPos_camPlane(1)), (relPos_carPlane[2] - relPos_camPlane(2));
    //std::cout << "rel pose inertial: " << relPos << std::endl;
}

void GimbalControl::Switch2CamFrame()
{
    carVel_ = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * carVel;
    fwVel_ = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * fwVel;
    fwAngVel_ =  R_camPan * R_panPlane * fwAngVel;
    relPos_camPlane_ = R_camPan * relPos_camPlane_pan;
    relPos_carCam_ =  R_camPan * relPos_carCam_pan;

    //std::cout << "came frame relPos_camPlane_: " << relPos_camPlane_[0] << ", " << relPos_camPlane_[1] << ", " << relPos_camPlane_[2] << std::endl;
    std::cout << "came frame relPos_carCam_: " << relPos_carCam_[0] << ", " << relPos_carCam_[1] << ", " << relPos_carCam_[2] << std::endl;
}
*/
void GimbalControl::calRelPoseUKF()
{
    /*
    Eigen::Vector3f relPos;

    // inertial frame
    relPos << (carPos_ukf.position.x - fwPos.position.x), (carPos_ukf.position.y - fwPos.position.y), (carPos_ukf.position.z - fwPos.position.z);
    // plane flu
    relPos_carPlane = Quat2RotaMatrix(quat_planeEarth_flu) * relPos;
    relPos_carCam << (relPos_carPlane[0] - relPos_camPlane(0)), (relPos_carPlane[1] - relPos_camPlane(1)), (relPos_carPlane[2] - relPos_camPlane(2));
*/
}

void GimbalControl::Switch2CamFrameUKF()
{
    /*
    carVel_ = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * carVel_ukf;
    fwVel_ = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd) * fwVel;
    fwAngVel_ =  R_camPan * R_panPlane * fwAngVel;
    relPos_camPlane_ = R_camPan * R_panPlane * Quat2RotaMatrix(baseLink_frd) * relPos_camPlane;
    relPos_carCam_ =  R_camPan * R_panPlane * Quat2RotaMatrix(baseLink_frd) * relPos_carCam;

    //std::cout << "came frame relPos_camPlane_: " << relPos_camPlane_[0] << ", " << relPos_camPlane_[1] << ", " << relPos_camPlane_[2] << std::endl;
    std::cout << "came frame relPos_carCam_: " << relPos_carCam_[0] << ", " << relPos_carCam_[1] << ", " << relPos_carCam_[2] << std::endl;
*/
}

void GimbalControl::UpdateTargetState(GimbalControl::Mode mode)
{
    depth = relPos_carCam_[2];
    state[2] = 1 / depth;

    if(mode == GimbalControl::measure_on)
    {
        state[0] = (u - cu) / fx; 
        state[1] = (v - cv) / fy; 
    }
    if(mode == GimbalControl::measure_off)
    {
        state[0] = relPos_carCam_[0] / depth;
        state[1] = relPos_carCam_[1] / depth; 
    }
    //std::cout << "state: " << state[0] << ", " << state[1] << ", " << state[2] << std::endl;
}

/*** Command: angular velocity by ROS ***/
void GimbalControl::TrackingControllerR(GimbalControl::Task cmd_behavior, GimbalControl::Uav uav, GimbalControl::Mode mode)
{   
    GimbalControl::Task behavior = cmd_behavior;
    GimbalControl::Uav vehicleType = uav;
    GimbalControl::Mode estimateState = mode;
    float dist1[3], dist2[3];

    if(vehicleType == GimbalControl::typhoon)
    {
        nh.getParam("typhoon/relPos_panPlane/x", dist1[0]);
        nh.getParam("typhoon/relPos_panPlane/y", dist1[1]);
        nh.getParam("typhoon/relPos_panPlane/z", dist1[2]);
        nh.getParam("typhoon/intrinsic_matrix/fx", fx);
        nh.getParam("typhoon/intrinsic_matrix/fy", fy);
        nh.getParam("typhoon/intrinsic_matrix/cu", cu);
        nh.getParam("typhoon/intrinsic_matrix/cv", cv);
        relPos_camPlane << dist1[0], dist1[1], dist1[2];
    }
    if(vehicleType == GimbalControl::miniyy)
    {
        nh.getParam("miniyy/relPos_panPlane/x", dist1[0]);
        nh.getParam("miniyy/relPos_panPlane/y", dist1[1]);
        nh.getParam("miniyy/relPos_panPlane/z", dist1[2]);
        nh.getParam("miniyy/relPos_camPan/x", dist2[0]);
        nh.getParam("miniyy/relPos_camPan/y", dist2[1]);
        nh.getParam("miniyy/relPos_camPan/z", dist2[2]);
        //nh.getParam("miniyy/intrinsic_matrix/fx", fx);
        //nh.getParam("miniyy/intrinsic_matrix/fy", fy);
        //nh.getParam("miniyy/intrinsic_matrix/cu", cu);
        //nh.getParam("miniyy/intrinsic_matrix/cv", cv);
        relPos_panPlane_flu << dist1[0], dist1[1], dist1[2];
        relPos_camPan_pan << dist2[0], dist2[1], dist2[2];
        //std::cout << "dist " << dist[0] << " " << dist[1] << " " << dist[2] << std::endl;
    }
    if(vehicleType == GimbalControl::techpod)
    {
        nh.getParam("techpod/relPos_panPlane/x", dist1[0]);
        nh.getParam("techpod/relPos_panPlane/y", dist1[1]);
        nh.getParam("techpod/relPos_panPlane/z", dist1[2]);
        nh.getParam("techpod/intrinsic_matrix/fx", fx);
        nh.getParam("techpod/intrinsic_matrix/fy", fy);
        nh.getParam("techpod/intrinsic_matrix/cu", cu);
        nh.getParam("techpod/intrinsic_matrix/cv", cv);
        relPos_camPlane << dist1[0], dist1[1], dist1[2];
    }

    int count = 0;
    int ckey = 0, old_ckey = 0;
    bool isUKFOn = 0;
    bool isYoloOn = 0;
    std::string controlMode = ""; 
    TicToc timer;

    while(ros::ok())
    {
        //timer.tic();
        ckey = getch();
        if(ckey != 0)
        {
            old_ckey = ckey;
        }
        //std::cout << "ckey in" << std::endl << "time consume (ms): " << timer.toc() << std::endl;
        std::cout << "key inserted: " << char(old_ckey) << std::endl;
        std::cout << "isDetected: " << isDetected << std::endl << std::endl;

        if(1)
        {   
            GimbalControl::calCamOrientation();

            if( (old_ckey != 0 && old_ckey == 101) || isUKFOn) // key (e)
            {
                GimbalControl::calRelPoseUKF();
                GimbalControl::Switch2CamFrameUKF();
                isUKFOn = 1;
                ROS_INFO("UKF worked...");
            }
            if( (old_ckey != 0 && old_ckey == 100) || !isUKFOn) // key (d)
            {
                GimbalControl::calRelPose();
                GimbalControl::Switch2CamFrame();
                isUKFOn = 0;
                ROS_INFO("UKF disable...");
            }

            if( (old_ckey != 0 && old_ckey == 121) || isYoloOn) // key (y)
            {
                depth = relPos_carCam_[2];
                state[2] = 1 / depth;
                state[0] = (u - cu) / fx; 
                state[1] = (v - cv) / fy; 
                isYoloOn = 1;
                lambda = 12;
                ROS_INFO("Yolo on...");
            }
            if( (old_ckey != 0 && old_ckey == 111) || !isYoloOn) // key (o)
            {
                depth = relPos_carCam_[2];
                state[2] = 1 / depth;
                state[0] = relPos_carCam_[0] / depth;
                state[1] = relPos_carCam_[1] / depth; 
                isYoloOn = 0;

                if(gain_push == 1)
                {
                    lambda = lambda_push;
                }
                else
                {
                    lambda = 21;
                }
                ROS_INFO("Yolo off...");
            }

            //GimbalControl::UpdateTargetState(estimateState);
            //GimbalControl::PrintData();
            std::cout << "cam info " << fx << " " << fy << " " << cu << ", " << cv << std::endl;

            std::cout << std::endl << "-------------- Error calculated by Yolo. ------------" << std::endl;
            std::cout << "error in u from yolo: " << u - cu << std::endl << "error in v from yolo: " << v - cv << std::endl << std::endl;


            error << (state[0] - targetState[0]), (state[1] - targetState[1]);
            std::cout << "states: " << state[0] << ", " <<  state[1] << std::endl;
            
            std::cout << "---------- Error calculated by 3D position. ----------" << std::endl;
            std::cout << "Error in the u-direction: " << relPos_carCam_[0]/depth*fx << " pixel" << std::endl;
            std::cout << "Error in the v-direction: " << relPos_carCam_[1]/depth*fy << " pixel" << std::endl;
            //std::cout << "focal length: " << fy << " pixel" << std::endl;
            //std::cout << "Error in the u-direction: " << state[0]*relPos_carCam_[2] << " m" << std::endl;
            //std::cout << "Error in the v-direction: " << state[1]*relPos_carCam_[2] << " m" << std::endl << std::endl;
            std::cout << "-------------------------------------------------------" << std::endl << std::endl;
            
            
            geometry_msgs::Point error_image;
            error_image.x = u - cu;
            error_image.y = v - cv;
            error_pub.publish(error_image);

            geometry_msgs::Point error_image_pos;
            error_image_pos.x = relPos_carCam_[0]/depth*fx;
            error_image_pos.y = relPos_carCam_[1]/depth*fy;
            error_pos_pub.publish(error_image_pos);

            
            L1r << state[0]*state[1],     -(1+state[0]*state[0]),
                  (1+state[1]*state[1]), -state[0]*state[1];

            L2 << -state[2], 0,         state[0]*state[2], state[0]*(state[1]+relPos_camPlane_[1]*state[2]),                                -(1+state[0]*state[0]+state[2]*(relPos_camPlane_[2]+relPos_camPlane_[0]*state[0])), state[1]+relPos_camPlane_[1]*state[2],
                  0,         -state[2], state[1]*state[2], 1+state[1]*state[1]+state[2]*(relPos_camPlane_[2]+relPos_camPlane_[1]*state[1]), -state[1]*(state[0]+relPos_camPlane_[0]*state[2]),                                  -state[0]-relPos_camPlane_[0]*state[2];
            
            L1_invr = L1r.inverse();
            knownTerm << (fwVel_[0]-carVel_[0]), (fwVel_[1]-carVel_[1]), (fwVel_[2]-carVel_[2]), fwAngVel_[0], fwAngVel_[1], fwAngVel_[2];

            //std::cout << "known terms: " << knownTerm << std::endl << std::endl;

            if(old_ckey != 0 && old_ckey == 116) // key (t)
            {
                controlMode = "normal";
            }
            if(old_ckey !=0 && old_ckey == 114) // key (r)
            {
                controlMode = "minus";
            }
            if(old_ckey !=0 && old_ckey == 108) // key (l)
            {
                std::cout << "Lock at current angle." << std::endl;
                controlMode = "";
            }
            if(old_ckey != 0 && old_ckey == 112) // key (p)
            {
                controlMode = "point";
            }
            if(controlMode == "normal")
            {
                std::cout << "Normal tracking." << std::endl;
                camAngVelr_ = - nu * L1_invr * L2 * knownTerm - lambda * L1_invr * error;
                isDetected = 1;
            }
            if(controlMode == "minus")
            {
                std::cout << "Tracking w/o L1 term." << std::endl;
                camAngVelr_ = - nu * L1_invr * L2 * knownTerm;
                isDetected = 1;
            }
            if(controlMode == "point")
            {
                std::cout << "Lock at given angle." << std::endl;
                GimbalControl::AngleControllerVel(angPitch, angYaw);
            }

            std::cout << "lambda: " << lambda << std::endl;
            //std::cout << "KTs:" << std::endl << knownTerm << std::endl;
            std::cout << "Desired angular velocity, L1: " << std::endl <<  - lambda * L1_invr * error << std::endl;
            std::cout << "Desired angular velocity, L2: " << std::endl <<  - nu * L1_invr * L2 * knownTerm << std::endl;
            //std::cout << "Desired angular velocity, roll: " << camAngVelr_[0]  << ", pitch: " << camAngVelr_[1] << std::endl;

            commandAngVel[0] = camAngVelr_[0];
            commandAngVel[1] = camAngVelr_[1];

            //std::cout << "Angular velocity, pitch: " << commandAngVel[0] << ", yaw: " << commandAngVel[1]/cos( gimbalAng[1] ) << std::endl;

            

            if(controlMode == "normal" || controlMode == "minus")
            {
                yawRate.data = commandAngVel[1] / cos( gimbalAng[1] );
                pitchRate.data = commandAngVel[0];
            }
            else if(controlMode == "point")
            {
                continue;;
            }
            else
            {
                yawRate.data = 0;
                pitchRate.data = 0;
            }

            //std::cout << "check cos(tilt): " << cos( gimbalAng[1] ) << std::endl;
            /*
            if(gimbalAng[1] < 0 )
            {
                std::cout << "tilt angle (degree): " << rad2Deg * gimbalAng[1]  - ceil( rad2Deg * gimbalAng[1] / 180 ) * 180 << std::endl;
            }
            else
            {
                std::cout << "tilt angle (degree): " << rad2Deg * gimbalAng[1]  - floor( rad2Deg * gimbalAng[1] / 180 ) * 180 << std::endl;
            }
            if(gimbalAng[2] < 0 )
            {
                std::cout << "pan angle (degree): " << rad2Deg * gimbalAng[2]  - ceil( rad2Deg * gimbalAng[2] / 180 ) * 180 << std::endl;
            }
            else
            {
                std::cout << "pan angle (degree): " << rad2Deg * gimbalAng[2]  - floor( rad2Deg * gimbalAng[2] / 180 ) * 180 << std::endl;
            }
            */
/*
            if( std::abs(yawRate.data) > 2.0)
            {
                yawRate.data = std::copysign( 2.0, yawRate.data);;
            }
            if( std::abs(pitchRate.data) > 2.0)
            {
                pitchRate.data = std::copysign( 2.0, pitchRate.data);;
            }
*/

            yawVelCommand_pub.publish(yawRate);
            pitchVelCommand_pub.publish(pitchRate);
            std::cout << "______________________________________________" << std::endl << std::endl;
        }

        GimbalControl::DataPub();
        
        ros::spinOnce();
        rate.sleep();
    }
    
}

void GimbalControl::AngleController(std::vector<float> &angVel)
{
    float timeStep = rate.expectedCycleTime().toSec();
    float gainPan = 1, gainTilt = 1;

    commandAng.pitch = rad2Deg * ( angRec[1] + gainTilt * angVel[0] * timeStep ); //rad2Deg * gimbalAng[1];     
    commandAng.yaw = rad2Deg * ( angRec[2] + gainPan * angVel[1] * timeStep );
    commandAng.roll = 0.0;

    angRec[1] += gainTilt * (angVel[0] * timeStep);
    angRec[2] += gainPan * (angVel[1] * timeStep);

    angCommand_pub.publish(commandAng);
    ros::Duration(0.7).sleep();
}

void GimbalControl::AngleControllerVel(float angPitch, float angYaw)
{
    float timeStep = rate.expectedCycleTime().toSec();
    float gainPan = 0.3, gainTilt = 0.3;

    std::cout << "angle command: " << angPitch << ", " << angYaw << std::endl; 
    std::cout << "angle error: " << angPitch -  gimbalAng[1] * rad2Deg << ", " << angYaw - gimbalAng[2] * rad2Deg << std::endl; 

    yawRate.data = gainPan * (angYaw * Deg2Rad -  gimbalAng[2]);
    pitchRate.data = gainTilt * (angPitch * Deg2Rad -  gimbalAng[1]);
    yawVelCommand_pub.publish(yawRate);
    pitchVelCommand_pub.publish(pitchRate);
}

void GimbalControl::AngleLock()
{
    yawRate.data = 0;
    pitchRate.data = 0;
    yawVelCommand_pub.publish(yawRate);
    pitchVelCommand_pub.publish(pitchRate);

    while(ros::ok())
    {

        GimbalControl::AngleControllerVel(angPitch, angYaw);

        ros::spinOnce();
        rate.sleep();
    }
}

void GimbalControl::Searching()
{
    if( twoDecimal(gimbalAng[2]) <= 80 * Deg2Rad)
    {
        yaw_direc = 1;
    }
    if( twoDecimal(gimbalAng[2]) >= 90 * Deg2Rad)
    {
        yaw_direc = -1;
    }
    if(yaw_direc == 1)
    {
        yawRate.data = 0.3;
    }
    if(yaw_direc == -1)
    {
        yawRate.data = -0.3;
    }

    if( twoDecimal(gimbalAng[1]) <= -20 * Deg2Rad)
    {
        pitch_direc = 1;
    }
    if( twoDecimal(gimbalAng[1]) >= 0 * Deg2Rad)
    {
        pitch_direc = -1;
    }
    if(pitch_direc == 1)
    {
        pitchRate.data = 0.2;
    }
    if(pitch_direc == -1)
    {
        pitchRate.data = -0.2;
    }

    yawVelCommand_pub.publish(yawRate);
    ros::Duration(0.01).sleep();
    pitchVelCommand_pub.publish(pitchRate);

    std::cout << "Angle: " << twoDecimal(gimbalAng[1]) << ", " << twoDecimal(gimbalAng[2]) << std::endl;
}

void GimbalControl::PrintData()
{
    std::cout << "------------<<<<<<<<<<<<<<<------------------>>>>>>>>>>>>>>--------------" << std::endl;
    Eigen::Matrix3f R_pan2Tilt;
    R_pan2Tilt =  rotationMatrix('Y', gimbalAng[1]);
    Eigen::Matrix3f R_tilt2cam;
    R_tilt2cam = rotationMatrix('X', 90*M_PI/180) * rotationMatrix('Z', 90*M_PI/180);
    std::cout << "Earth to uav flu: " << std::endl << Quat2RotaMatrix(quat_planeEarth_flu) << std::endl 
    << "Earth to uav frd: " << std::endl << Quat2RotaMatrix(quat_planeEarth_frd) << std::endl
    << "Uav frd to pan: " << std::endl << R_panPlane << std::endl
    << "Pan to tilt: " << std::endl << R_pan2Tilt << std::endl
    << "Tilt to camera: " << std::endl << R_tilt2cam << std::endl
    << "Gimbal pan angle: " << gimbalAng[2] << std::endl
    << "Gimbal tilt angle: " << gimbalAng[1] << std::endl;

    std::cout << "------------<<<<<<<<<<<<<<<------------------>>>>>>>>>>>>>>--------------" << std::endl;
    Eigen::Vector3f fwPositon;
    fwPositon << fwPos.position.x, fwPos.position.y, fwPos.position.z;
    Eigen::Vector3f carPositon;
    carPositon << carPos.position.x, carPos.position.y, carPos.position.z;
    Eigen::Vector3f relPos;
    relPos << (carPos.position.x - fwPos.position.x), (carPos.position.y - fwPos.position.y), (carPos.position.z - fwPos.position.z);
    std::cout << "UAV position: " << std::endl << R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_frd)*fwPositon << std::endl
    << "Car position: " << std::endl << R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_frd)*carPositon << std::endl
    << "Rel position: " << std::endl << R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_frd)*relPos << std::endl
    << "camera position: " << std::endl << R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_flu)*relPos_camPlane + R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_frd)*fwPositon << std::endl
    << "UAV velocity: " << std::endl << R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_frd)*fwVel << std::endl 
    << "Car velocity: " << std::endl << R_camPan*R_panPlane*Quat2RotaMatrix(quat_planeEarth_frd)*carVel << std::endl;

    std::cout << "------------<<<<<<<<<<<<<<<------------------>>>>>>>>>>>>>>--------------" << std::endl;
}

void GimbalControl::DataPub()
{
    cam_value.fx.data = fx;
    cam_value.fy.data = fy;
    cam_value.cu.data = cu;
    cam_value.cv.data = cv;
    cam_value.u.data = u;
    cam_value.v.data = v;
    cam_value.isDetected.data = isDetected;

    dyn_value.target_vel.x = carVel_(0);
    dyn_value.target_vel.y = carVel_(1);
    dyn_value.target_vel.z = carVel_(2);
    dyn_value.uav_vel.x = fwVel_(0);
    dyn_value.uav_vel.y = fwVel_(1);
    dyn_value.uav_vel.z = fwVel_(2);
    dyn_value.uav_wvel.x = fwAngVel_(0);
    dyn_value.uav_wvel.y = fwAngVel_(1);
    dyn_value.uav_wvel.z = fwAngVel_(2);
    dyn_value.pt_wvel.x = 0;
    dyn_value.pt_wvel.y = camAngVelr_(0);
    dyn_value.pt_wvel.z = camAngVelr_(1);

    dyn_value.camuav_pose.x = relPos_camPlane_(0);
    dyn_value.camuav_pose.y = relPos_camPlane_(1);
    dyn_value.camuav_pose.z = relPos_camPlane_(2);
    dyn_value.targetcam_pose.x = relPos_carCam_(0);
    dyn_value.targetcam_pose.y = relPos_carCam_(1);
    dyn_value.targetcam_pose.z = relPos_carCam_(2);

    dyn_value.target_vel_inertial.x = carVel(0);
    dyn_value.target_vel_inertial.y = carVel(1);
    dyn_value.target_vel_inertial.z = carVel(2);
    dyn_value.target_pose_inertial.x = carPos.position.x;
    dyn_value.target_pose_inertial.y = carPos.position.y;
    dyn_value.target_pose_inertial.z = carPos.position.z;
    
    Eigen::Vector3f relPos_camPlane_gnd;
    relPos_camPlane_gnd = (Quat2RotaMatrix(quat_planeEarth_flu)).transpose() * relPos_camPlane;
    //std::cout << "came frame relPos_camPlane: " << relPos_camPlane[0] << ", " << relPos_camPlane[1] << ", " << relPos_camPlane[2] << std::endl;
    //std::cout << "came frame relPos_camPlane_gnd: " << relPos_camPlane_gnd[0] << ", " << relPos_camPlane_gnd[1] << ", " << relPos_camPlane_gnd[2] << std::endl;

    dyn_value.cam_pose_inertial.x = fwPos.position.x + relPos_camPlane_gnd[0]; 
    dyn_value.cam_pose_inertial.y = fwPos.position.y + relPos_camPlane_gnd[1];
    dyn_value.cam_pose_inertial.z = fwPos.position.z + relPos_camPlane_gnd[2];
    //std::cout << "fwPos.position: " << fwPos.position.x << ", " << fwPos.position.y << ", " << fwPos.position.z << std::endl;

    Eigen::Matrix3f R_g2c;
    R_g2c = R_camPan * R_panPlane * Quat2RotaMatrix(quat_planeEarth_frd);
    dyn_value.rot_g2c.data = {R_g2c.coeff(0, 0), R_g2c.coeff(0, 1), R_g2c.coeff(0, 2), 
                                R_g2c.coeff(1, 0), R_g2c.coeff(1, 1), R_g2c.coeff(1, 2),
                                R_g2c.coeff(2, 0), R_g2c.coeff(2, 1), R_g2c.coeff(2, 2)};

    //std::cout << "R_g2c: " << R_g2c << std::endl;

    estimate_dyn_pub.publish(dyn_value);
    estimate_cam_pub.publish(cam_value);
}

/*** Command: angle through MAVlink ***/
void GimbalControl::MountShow1()
{
    commandAng.roll = 0;
    commandAng.yaw = 0;
    commandAng.pitch = 0;
    angCommand_pub.publish(commandAng);

    float yaw = 0, pitch = 0; // units: degree

    while(ros::ok()){
        if(yaw >= 30){
            break;
        }

        commandAng.yaw = yaw;
        std::cout << "yaw: " << yaw << ",  " << "pitch: " << pitch << std::endl;
        yaw++;

        angCommand_pub.publish(commandAng);
        ros::Duration(0.05).sleep();
    }
    
    while(ros::ok()){
        if(yaw <= -30){
            break;
        }

        commandAng.yaw = yaw;
        std::cout << "yaw: " << yaw << ",  " << "pitch: " << pitch << std::endl;
        yaw--;

        angCommand_pub.publish(commandAng);
        ros::Duration(0.05).sleep();
    }
    while(ros::ok()){
        if(yaw >= 0){
            break;
        }

        commandAng.yaw = yaw;
        std::cout << "yaw: " << yaw << ",  " << "pitch: " << pitch << std::endl;
        yaw++;

        angCommand_pub.publish(commandAng);
        ros::Duration(0.05).sleep();
    }
    while(ros::ok()){
        if(pitch >= 20){
            break;
        }

        commandAng.pitch = pitch;
        std::cout << "yaw: " << yaw << ",  " << "pitch: " << pitch << std::endl;
        pitch++;

        angCommand_pub.publish(commandAng);
        ros::Duration(0.05).sleep();
    }
    while(ros::ok()){
        if(pitch <= -20){
            break;
        }

        commandAng.pitch = pitch;
        std::cout << "yaw: " << yaw << ",  " << "pitch: " << pitch << std::endl;
        pitch--;

        angCommand_pub.publish(commandAng);
        ros::Duration(0.05).sleep();
    }
    while(ros::ok()){
        if(pitch >= 0){
            break;
        }

        commandAng.pitch = pitch;
        std::cout << "yaw: " << yaw << ",  " << "pitch: " << pitch << std::endl;
        pitch++;

        angCommand_pub.publish(commandAng);
        ros::Duration(0.05).sleep();
    }
}

/*** Command: anglar velocity through ROS ***/
void GimbalControl::MountShow2()
{
    yawRate.data = 0;
    pitchRate.data = 0;
    yawVelCommand_pub.publish(yawRate);
    pitchVelCommand_pub.publish(pitchRate);

    float yaw_rate = 0.5, pitch_rate = 0.5; // units: rad/s

    while(ros::ok()){
        if( gimbalAng[2] >= 25 * Deg2Rad){
            break;
        }

        yawRate.data = yaw_rate;
        yawVelCommand_pub.publish(yawRate);

        ros::spinOnce();
        rate.sleep();
    }
    
    while(ros::ok()){
        if( gimbalAng[2] <= -25 * Deg2Rad){
            break;
        }

        yawRate.data = -yaw_rate;
        yawVelCommand_pub.publish(yawRate);

        ros::spinOnce();
        rate.sleep();
    }
    
    while(ros::ok()){
        if( gimbalAng[2] >= 0 * Deg2Rad){
            yawRate.data = 0;
            yawVelCommand_pub.publish(yawRate);
            break;
        }

        yawRate.data = yaw_rate;
        yawVelCommand_pub.publish(yawRate);

        ros::spinOnce();
        rate.sleep();
    }

    while(ros::ok()){
        if( gimbalAng[1] >= 15 * Deg2Rad){
            break;
        }

        pitchRate.data = pitch_rate;
        pitchVelCommand_pub.publish(pitchRate);

        ros::spinOnce();
        rate.sleep();
    }
    
    while(ros::ok()){
        if( gimbalAng[1] <= -15 * Deg2Rad){
            break;
        }

        pitchRate.data = -pitch_rate;
        pitchVelCommand_pub.publish(pitchRate);

        ros::spinOnce();
        rate.sleep();
    }
    
    while(ros::ok()){
        if( gimbalAng[1] >= 0 * Deg2Rad){
            pitchRate.data = 0;
            pitchVelCommand_pub.publish(pitchRate);
            break;
        }

        pitchRate.data = pitch_rate;
        pitchVelCommand_pub.publish(pitchRate);

        ros::spinOnce();
        rate.sleep();
    }
}

